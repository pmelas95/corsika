
{
#include "TROOT.h"
#include "TFile.h"
#include "TTree.h"
#include "TBrowser.h"
#include "TH2.h"
#include "TRandom.h"
#include <numeric>
#include <vector>
#include <iostream>
#include <iomanip> // For std::fixed and std::setprecision


//   c1 = new TCanvas("c1","A Simple Graph with error bars",200,10,800,600);
//   c1->SetFillColor(10);
//   c1->Divide(2,1);
//   c1->cd(1);
//   c1->SetLogy();

gInterpreter->GenerateDictionary("vector<vector<int> >", "vector");

//TFile *fout=new TFile("MC_shists.root","RECREATE");
TFile *fout=new TFile("aaa3.root","RECREATE");
//TFile *fout=new TFile("winter.root","RECREATE");
//TFile *fout=new TFile("MC100_hist.root","RECREATE");
//TFile *fout=new TFile("6201_hist.root","RECREATE");
//TFile *fout=new TFile("/exp/dune/app/users/pmelas/v09_09_00/minis/length_15/8676_hists.root","RECREATE");
//TFile *fout=new TFile("/exp/dune/app/users/pmelas/v09_09_00/minis/y_loose*/6201_hists.root","RECREATE");
//TFile *fout=new TFile("/home/lab/x/6118_hists.root","RECREATE");
//TFile *fout=new TFile("10444_hist.root","RECREATE");
//TFile *fout=new TFile("SCE_100_hists.root","RECREATE");
TTree *t1 = new TTree("t1","a simple Tree with simple variables");


// /exp/dune/app/users/pmelas/v09_09_00/xml/

//TFile *f8 = new TFile("/pnfs/dune/scratch/users/pmelas/v09_09_00/ana2/run10529_output/anahist.root");
//TFile *f8 = new TFile("/exp/dune/app/users/pmelas/v09_09_00/xml/8676_new.root");
//TFile *f8 = new TFile("6201_new.root");
//TFile *f8 = new TFile("/exp/dune/app/users/pmelas/v09_09_00/xml/70ms_2.root");
//TFile *f8 = new TFile("Compliteness_mc.root");
//TFile *f8 = new TFile("/home/lab/simulated100_mine4.root");
////////////// CORSIKA TESTS ///////////////////
//TFile *f8 = new TFile("winter_1100.root"); // NEW WINTER
TFile *f8 = new TFile("summer_455_atmod6.root");
//TFile *f8 = new TFile("winter_testing.root"); 
//TFile *f8 = new TFile("winter_1100_atmod8.root");
//TFile *f8 = new TFile("WINTER.root");
//TFile *f8 = new TFile("/home/lab/corsika_extra/WINTER_AMIT.root"); // NEW SUMMER
//TFile *f8 = new TFile("/home/lab/amit_winter2.root");
//TFile *f8 = new TFile("amit_winter.root");
//TFile *f8 = new TFile("mine_winter2.root");
//TFile *f8 = new TFile("mine_summer.root");
////////////////////////////////////////////////////
//TFile *f8 = new TFile("simulated92_mine4.root ");
//TFile *f8 = new TFile("/dune/app/users/pmelas/v09_09_00/xml/simulated100_mine4.root ");
//TFile *f8 = new TFile("/pnfs/dune/persistent/users/pmelas/8676_new.root");
//TFile *f8 = new TFile("/pnfs/dune/persistent/users/pmelas/6119+6118_new.root");
TTree *t8 = (TTree*)f8->Get("myana/TheONE");


TH1F *TCOSMIC_8904_2 = new TH1F("TCOSMIC_8904_2","Minimum Distance;Minimum Distance(cm);Counts",100,-0.0001,1200);
TH1F *TCOSMIC_8904_1 = new TH1F("TCOSMIC_8904_1","Minimum Distance;Minimum Distance(cm);Counts",20,-0.0001,40);
TH1F *TCOSMIC_8904_3 = new TH1F("TCOSMIC_8904_3","Minimum Distance;Minimum Distance(cm);Counts",100,-0.0001,1200);

//50,0,400
//50,0,20
TH1F *E_TRUTH = new TH1F("E_TRUTH ","Muon's True Energy;Energy(GeV);Counts",50,0,400);
TH1F *E_TRUTH52 = new TH1F("E_TRUTH52 ","Muon's True Energy;Energy(GeV);Counts",50,0,400);
TH1F *E_TRUTH50 = new TH1F("E_TRUTH50 ","Muon's True Energy ;Energy(GeV);Counts",50,0,400);

TH1F *Com = new TH1F("Com","Completeness;Completeness;Counts",50,0,1);
TH1F *Pur = new TH1F("Pur","Purity;Purity;Counts",50,0,1);



TH1F *COSMIC_8901 = new TH1F("COSMIC_8901","Azimuth Angle;Angle(deg);Counts",15,-200,200);
TH1F *Track_Azimuth_Noerror = new TH1F("Track_Azimuth_Noerror","Azimuth Angle;Angle(deg);Counts",15,-200,200);
TH1F *Track_Azimuth_Systematics = new TH1F("Track_Azimuth_Systematics","Azimuth Angle;Angle(deg);Counts",15,-200,200);
TH1F *Track_Azimuth_Only_Systematics = new TH1F("Track_Azimuth_Only_Systematics","Azimuth Angle;Angle(deg);Counts",15,-200,200);


TH1F *Track_Truth_Gene = new TH1F("Track_Truth_Gene", "Truth Gene; Gene; Entries", 100, 0, 100); 
TH1F *Track_Truth_ProductionY = new TH1F("Track_Truth_ProductionY", "Truth Production Y; Y [m]; Entries", 50, 0, 48000); 
TH1F *Track_Truth_ProductionY52 = new TH1F("Track_Truth_ProductionY52", "Truth Production Y ; Y [m]; Entries", 50, 0, 48000);
TH1F *Track_Truth_ProductionY50 = new TH1F("Track_Truth_ProductionY50", "Truth Production Y ; Y [m]; Entries", 50, 0, 48000);

TH1F *Track_Truth_DTMin = new TH1F("Track_Truth_DTMin", "Truth DTMin; DTMin [ns]; Entries", 100, 0, 1000);
TH1F *Track_Truth_MinDT = new TH1F("Track_Truth_MinDT", "Truth MinDT; MinDT [ns]; Entries", 10, 0, 10);
TH1F *Track_Truth_DT = new TH1F("Track_Truth_DT", "Truth DT; DT [ns]; Entries", 100, 0, 100);
TH1F *Track_Truth_Min = new TH1F("Track_Truth_Min", "Truth Min Distance; Distance [m]; Entries", 100, 0, 4000);


TH2F *h2_min_dt0 = new TH2F("h2_min_dt0", "All Muons; Distance [m]; DTime [ns]", 50, 0, 10000, 10, 0, 500);

TH2F *h2_min_dt1 = new TH2F("h2_min_dt1", "All Muons; Distance [m]; DTime [ns]", 50, 0, 1000, 10, 0, 10);
  //TH2F *h2_min_dt1 = new TH2F("h2_min_dt1", "Muons generation != 52; Distance [m]; DTime [ns]", 50, 0, 1000, 10, 0, 10);
  TH2F *h2_min_dt2 = new TH2F("h2_min_dt2", "Muons gewneration == 52; Distance [m]; DTime [ns]", 50, 0, 1000, 10, 0, 10);

//TH2F *h2_min_dt3 = new TH2F("h2_min_dt3", "All Muons; Distance [m]; DTime [ns]", 50, 0, 1000, 10, 0, 10);



//TH1F *COSMIC_8902 = new TH1F("COSMIC_8902","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0,50.);

//TH1F *Track_Zenith = new TH1F("Track_Zenith","Zenith Angle;Angle(deg);Counts",120,-200.5,200.5);
//TH1F *Track_Zenith = new TH1F("Track_Zenith","Zenith Angle;Angle(deg);Counts",15,-0.5,90.5);

Double_t bins2[] = {0,6,12,18,24,30,36,42,48,54,60,66,72,78,90};
Int_t nbins2 = sizeof(bins2) / sizeof(Double_t) - 1; // Number of bins

TH1F *Track_Zenith = new TH1F("Track_Zenith","Zenith Angle;Angle(deg);Counts",nbins2, bins2);
TH1F *Track_Zenith_Systematics = new TH1F("Track_Zenith_Systematics","Zenith Angle;Angle(deg);Counts",nbins2, bins2);
TH1F *Track_Zenith_Only_Systematics = new TH1F("Track_Zenith_Only_Systematics","Zenith Angle;Angle(deg);Counts",nbins2, bins2);
TH1F *Track_Zenith_Noerror = new TH1F("Track_Zenith_Noerror","Zenith Angle;Angle(deg);Counts",nbins2, bins2);



Double_t bins[] = {0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 680, 700, 730, 760, 810, 860, 910, 960, 990};
Int_t nbins = sizeof(bins) / sizeof(Double_t) - 1; // Number of bins

// Create the histogram with variable binning
TH1F *Track_Length = new TH1F("Track_Length", "Cosmic Track Length; Length (cm); Counts", nbins, bins);
TH1F *Track_LengthYZ_Noerror = new TH1F("Track_Length_Noerror","Cosmic Track Length ;Length(cm);Counts",nbins, bins);
TH1F *Track_LengthYZ_Systematics = new TH1F("Track_Length_Systematics","Cosmic Track Length ;Length(cm);Counts",nbins, bins);
TH1F *Track_LengthYZ_Only_Systematics = new TH1F("Track_Length_Only_Systematics","Cosmic Track Length ;Length(cm);Counts",nbins, bins);

/*
TH1F *Track_LengthYZ_Noerror = new TH1F("Track_Length_Noerror","Cosmic Track Length ;Length(cm);Counts",66,0,990);
TH1F *Track_LengthYZ_Systematics = new TH1F("Track_Length_Systematics","Cosmic Track Length ;Length(cm);Counts",66,0,990);
TH1F *Track_LengthYZ_Only_Systematics = new TH1F("Track_Length_Only_Systematics","Cosmic Track Length ;Length(cm);Counts",66,0,990);
*/


TH1F *COSMIC_8904 = new TH1F("COSMIC_8904","Cosmic Track Length;Length(cm);Counts",60,0,1200);



TH1F *COSMIC_8905 = new TH1F("COSMIC_8905","Cosmic Track Angle Theta;Theta(deg);Counts",60,0,180);
TH1F *Track_Theta_Noerror = new TH1F("Track_Theta_Noerror","Cosmic Track Angle Theta;Theta(deg);Counts",60,0,180);
TH1F *Track_Theta_Systematics = new TH1F("Track_Theta_Systematics","Cosmic Track Angle Theta;Theta(deg);Counts",60,0,180);
TH1F *Track_Theta_Only_Systematics = new TH1F("Track_Theta_Only_Systematics","Cosmic Track Angle Theta;Theta(deg);Counts",60,0,180);


TH1F *Track_Phi_Noerror = new TH1F("Track_Phi_Noerror","Track Angle Phi;Phi(deg);Counts",20,-200,0);
TH1F *Track_Phi = new TH1F("Track_Phi","Track Angle Phi;Phi(deg);Counts",20,-200,0);
TH1F *Track_Phi_Systematics = new TH1F("Track_Phi_Systematics","Track Angle Phi;Phi(deg);Counts",20,-200,0);
TH1F *Track_Phi_Only_Systematics = new TH1F("Track_Phi_Only_Systematics","Track Angle Phi;Phi(deg);Counts",20,-200,0);


TH1F *Track_AngleYZ = new TH1F("Track_AngleYZ","Track Angle YZ;Angle YZ(deg);Counts",20,-200,0);

TH1F *COSMIC_8907 = new TH1F("COSMIC_8907","X Starting Point;X(cm);Counts",95,-850,850);
TH1F *COSMIC_8908 = new TH1F("COSMIC_8908","X Ending Point;X(cm);Counts",95,-850,850);
TH1F *COSMIC_89010 = new TH1F("COSMIC_89010","Y Ending Point;Y(cm);Counts",55,-20,630);
//TH1F *COSMIC_89011 = new TH1F("COSMIC_89011","Z Starting Point;Z(cm);Counts",90,-10,100);
//TH1F *COSMIC_89012 = new TH1F("COSMIC_89012","Z Ending Point;Z(cm);Counts",90,-10,710);

TH3D *fffms = new TH3D("fffms","XYZ",100,-150,850,100,-10,610,100,-10,710);
TH3D *f33ms = new TH3D("f33ms","XYZ",100,-150,850,100,-10,610,100,-10,710);

TH2D *f2ms = new TH2D("_2D_plot","Y vs Z;Y (cm);Z(cm)",50,570,602,100,-10,710);
TH2D *f2me = new TH2D("_2D_plot_","Y vs Z;Y (cm);Z(cm)",50,-2,30,100,-10,710);


//TH2D *f2me = new TH2D("f2me","Y vs Z;Y (cm);Z(cm)",100,-20,630,100,-10,710);
//TH2D *f2ms = new TH2D("f2ms","Y vs Z;Y (cm);Z(cm)",100,-20,630,100,-10,710);

//TH2D *f22ms = new TH2D("f22ms","Phi vs Zenith;Phi(deg);Zenith(deg)",40,-180,180,30,-0.5,90.5);
TH2D *f22ms = new TH2D("f22ms","Azimuth vs Zenith;Azimuth(deg);Zenith(deg)",40,-180,180,30,-0.5,90.5);

TH2D *fl = new TH2D("fl","3D Length vs 2D Length ;3D Length(cm);2D Length(cm)",120,0,120,120,0,120);


TH2D *f2D = new TH2D("Truth Info","Minimum Distance vs Cos(theta);Minimum Distance(cm) ;Cos(theta)",100,-0.0001,1200,50,0,1);
TH2D *f2Dss = new TH2D("f2Dss","Minimum Distance vs Cos(theta);Minimum Distance(cm) ;Cos(theta)",11,0,200,200,0.8,1);

//TH1F *COSMIC_8902 = new TH1F("COSMIC_8902","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0,50.);
//TH1F *Counter = new TH1F("Counter","Number of multi-muons per Event;Number of multi-muons per Event;Counts",17,0.5,50.5);
//TH1F *Air = new TH1F("Air","Number of Air Shower per Event;Number of Air Shower per Event;Counts",15,0.5,15.5);
//TH1F *Single = new TH1F("Single","Number of single-muons per Event;Number of single-muons per Event;Counts",17,0,50);

//TH1F *Track_Multiplicity = new TH1F("Track_Multiplicity","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",41,0.,40);
TH1F *Track_Multiplicity = new TH1F("Track_Multiplicity","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",15,0.,30);
TH1F *Track_Multiplicity_Systematics = new TH1F("Track_Multiplicity_Systematics","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",15,0,30);
TH1F *Track_Multiplicity_Only_Systematics = new TH1F("Track_Multiplicity_Only_Systematics","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",15,0,30);
TH1F *Track_Multiplicity_Noerror = new TH1F("Track_Multiplicity_Noerror","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",15,0,30);

/*
TH1F *Track_Multiplicity = new TH1F("Track_Multiplicity","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0.,50);
TH1F *Track_Multiplicity_Systematics = new TH1F("Track_Multiplicity_Systematics","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0,50);
TH1F *Track_Multiplicity_Only_Systematics = new TH1F("Track_Multiplicity_Only_Systematics","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0,50);
TH1F *Track_Multiplicity_Noerror = new TH1F("Track_Multiplicity_Noerror","Number of Cosmic PFParticles Per Event;Number of Cosmic PFParticles;Counts",17,0,50);
*/
TH1F *Parallel_per_cone = new TH1F("Parallel_per_cone","Number of muons per Air Shower;Number of muons;Counts",11,0,10);

TH1F *Track_StartY                  = new TH1F("Track_StartY","Y Starting Point;Y(cm);Counts",33,-20,640);
TH1F *Track_StartY_Systematics      = new TH1F("Track_StartY_Systematics","Y Starting Point;Y(cm);Counts",33,-20,640);
TH1F *Track_StartY_Only_Systematics = new TH1F("Track_StartY_Only_Systematics","Y Starting Point;Y(cm);Counts",33,-20,640);
TH1F *Track_StartY_Noerror          = new TH1F("Track_StartY_Noerror","Y Starting Point;Y(cm);Counts",33,-20,640);

TH1F *Track_EndY                  = new TH1F("Track_EndY","Y Ending Point;Y(cm);Counts",33,-20,640);
TH1F *Track_EndY_Systematics      = new TH1F("Track_EndY_Systematics","Y Ending Point;Y(cm);Counts",33,-20,640);
TH1F *Track_EndY_Only_Systematics = new TH1F("Track_EndY_Only_Systematics","Y Ending Point;Y(cm);Counts",33,-20,640);
TH1F *Track_EndY_Noerror          = new TH1F("Track_EndY_Noerror","Y Ending Point;Y(cm);Counts",33,-20,640);

TH1F *Track_StartZ                  = new TH1F("Track_StartZ","Z Starting Point;Z(cm);Counts",55,-10,710);
TH1F *Track_StartZ_Systematics      = new TH1F("Track_StartZ_Systematics","Z Starting Point;Z(cm);Counts",55,-10,710);
TH1F *Track_StartZ_Only_Systematics = new TH1F("Track_StartZ_Only_Systematics","Z Starting Point;Z(cm);Counts",55,-10,710);
TH1F *Track_StartZ_Noerror          = new TH1F("Track_StartZ_Noerror ","Z Starting Point;Z(cm);Counts",55,-10,710);

TH1F *Track_EndZ                    = new TH1F("Track_EndZ","Z Ending Point;Z(cm);Counts",55,-10,710);
TH1F *Track_EndZ_Systematics        = new TH1F("Track_EndZ_Systematics","Z Ending Point;Z(cm);Counts",55,-10,710);
TH1F *Track_EndZ_Only_Systematics   = new TH1F("Track_EndZ_Only_Systematics","Z Ending Point;Z(cm);Counts",55,-10,710);
TH1F *Track_EndZ_Noerror            = new TH1F("Track_EndZ_Noerror ","Z Ending Point;Z(cm);Counts",55,-10,710);

TH1F *Counter = new TH1F("Counter","Number of multi-muons per Event;Number of multi-muons per Event;Counts",30,-0.05,30.05);
//TH1F *Counter = new TH1F("Counter","Number of multi-muons per Event;Number of multi-muons per Event;Counts",15,-0.05,30.05);
TH1F *Air     = new TH1F("Air"    ,"Number of Air Shower per Event;Number of Air Shower per Event;Counts",15,-0.05,15.05);
TH1F *Single  = new TH1F("Single" ,"Number of single-muons per Event;Number of single-muons per Event;Counts",15,-0.05,30.05);


TH1F *PDG = new TH1F("PDG","PDG;PDG;Counts",3000,-500,2500);

TH1F *Cos = new TH1F("Cos","Costheta_xz;Costheta_xz;Counts",110,-0.01,1.11);

//TH1F *HITS= new TH1F("HITS","Number of hits;Nhits;Counts",100,0,3000);
TH1F *HITS= new TH1F("HITS","Number of hits;Nhits;Counts",1000,0,3000);
TH1F *HITS2= new TH1F("HITS2","Number of hits/Track length;Nhits;Counts",100,0,10);


TH1F *Angle2= new TH1F("Angle2","Angle Between 2 Tracks;cos(theta_2);Counts",50,0,1);
TH1F *Angle3= new TH1F("Angle3","Angle Between 2 Tracks;cos(theta_2);Counts",2000,0,1);
TH1F *Angle4= new TH1F("Angle4","Angle Between 2 Tracks;cos(theta_2);Counts",2000,0,1);
TH1F *Angle= new TH1F("Angle","Angle Between 2 Tracks;cos(theta_2);Counts",2000,0,1);

Track_Truth_Gene->Sumw2();
Track_Truth_ProductionY->Sumw2();
Track_Truth_DTMin->Sumw2();
Track_Truth_MinDT->Sumw2();
Track_Truth_DT->Sumw2();
Track_Truth_Min->Sumw2();
h2_min_dt1->Sumw2();
h2_min_dt2->Sumw2();
PDG->Sumw2();
Parallel_per_cone->Sumw2();
Track_Multiplicity->Sumw2();
Track_Multiplicity_Systematics->Sumw2();
Track_Multiplicity_Only_Systematics->Sumw2();
Track_Multiplicity_Noerror->Sumw2();
Track_StartY->Sumw2();
Track_StartY_Systematics->Sumw2();
Track_StartY_Only_Systematics->Sumw2();
Track_StartY_Noerror->Sumw2();
Track_EndY->Sumw2();
Track_EndY_Systematics->Sumw2();
Track_EndY_Only_Systematics->Sumw2();
Track_EndY_Noerror->Sumw2();
Track_StartZ->Sumw2();
Track_StartZ_Systematics->Sumw2();
Track_StartZ_Only_Systematics->Sumw2();
Track_StartZ_Noerror->Sumw2();
Track_EndZ->Sumw2();
Track_EndZ_Systematics->Sumw2();
Track_EndZ_Only_Systematics->Sumw2();
Track_EndZ_Noerror->Sumw2();
Counter->Sumw2();
Air->Sumw2();
Single->Sumw2();
HITS->Sumw2();
Angle2->Sumw2();
Angle3->Sumw2();
Angle4->Sumw2();
Angle->Sumw2();
TCOSMIC_8904_2->Sumw2();
TCOSMIC_8904_1->Sumw2();
TCOSMIC_8904_3->Sumw2();
E_TRUTH->Sumw2();
Com->Sumw2();
Pur->Sumw2();
COSMIC_8901->Sumw2();
Track_Zenith->Sumw2();
Track_Zenith_Systematics->Sumw2();
Track_Zenith_Only_Systematics->Sumw2();
Track_Zenith_Noerror->Sumw2();
Track_LengthYZ_Noerror->Sumw2();
Track_Length->Sumw2();
Track_LengthYZ_Systematics->Sumw2();
Track_LengthYZ_Only_Systematics->Sumw2();
COSMIC_8904->Sumw2();
COSMIC_8905->Sumw2();
Track_Phi->Sumw2();
Track_AngleYZ->Sumw2();
COSMIC_8907->Sumw2();
COSMIC_8908->Sumw2();
COSMIC_89010->Sumw2();
fffms->Sumw2();
f33ms->Sumw2();
f2ms->Sumw2();
f22ms->Sumw2();
f2D->Sumw2();
f2Dss->Sumw2();

Track_Phi_Noerror->Sumw2();
Track_Phi_Systematics->Sumw2();
Track_Phi_Only_Systematics->Sumw2();
Track_Theta_Noerror->Sumw2();
Track_Theta_Systematics->Sumw2();
Track_Theta_Only_Systematics->Sumw2();
Track_Azimuth_Noerror->Sumw2();
Track_Azimuth_Systematics->Sumw2();
Track_Azimuth_Only_Systematics->Sumw2();



 //gStyle->SetOptStat("n");

UInt_t          event;
std::vector<double>* AZIMUTH2 = 0;
std::vector<double>* ZENITH2 = 0;
std::vector<double>* EVERYTRACK_PHI2 = 0;
std::vector<double>* EVERYTRACK_ANGLE2 = 0;
std::vector<double>* EVERYTRACK_LENGTH2 = 0;
std::vector<double>* EVERYTRACK_STARTX2 = 0;
std::vector<double>* EVERYTRACK_ENDX2 = 0;   
std::vector<double>* EVERYTRACK_STARTZ2 = 0;
std::vector<double>* EVERYTRACK_ENDZ2 = 0;
std::vector<double>* EVERYTRACK_STARTY2 = 0;
std::vector<double>* EVERYTRACK_ENDY2 = 0;
std::vector<double>* EVERYTRACK_THETAYZ = 0;
std::vector<double>* EVERYTRACK_THETAXZ = 0;
std::vector<vector<int>>* FIRSTCHANNELTPC = 0;
std::vector<vector<double>>* Xpoint = 0;
std::vector<vector<double>>* Ypoint = 0;
std::vector<vector<double>>* Zpoint = 0;
std::vector<double>* EVERYTRACK_TRUTH_GENE2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_PRODUCTIONY2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_DTMIN2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_MINDT2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_DT2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_MIN2  = 0;

std::vector<double>* PURITY = 0;
std::vector<double>* Completeness = 0;
std::vector<double>* TO = 0;
std::vector<double>* TruthPhi2 = 0;
std::vector<double>* TruthTheta2 = 0;
std::vector<double>* EVERYTRACK_TRUTH_STARTPOINTX22 = 0;
std::vector<double>* TruthStartY2 = 0;
std::vector<double>* TruthStartZ2 = 0;
std::vector<double>* TruthEndX2 = 0;
std::vector<double>* TruthEndY2 = 0;
std::vector<double>* TruthEndZ2 = 0;
std::vector<int>* LASTCHANNELTPC = 0;
std::vector<int>* EVERYTRACK_TRUTH_PDG2 = 0;
std::vector<double>* TruthEnergy2 = 0;

std::vector<double> vector_zenith,vector_phi,vector_minimum_distance2,vector_angle;

double x,z,t;
double Y,minimum_distance2,angle;
//std::vector<int> K,Kk,KK,Koo,KO,Kooo,Kook,Kooko;
std::vector<double> Startingx,Startingy,Startingz,Endingx,Endingy,Endingz,positive_or_negative,ZENITH,ZENITH_PARALLEL,E_truth,completeness,purity,Costhetaxz,exl,eyl,particl,eve;
std::vector<double> Zpoint2,Xpoint2,Ypoint2,startingx,startingy,startingz,endingx,endingy,endingz,azimuth,zenith,phi,theta,length2,lengthyz,ZPoint2,XPoint2,YPoint2;
std::vector<vector<double>> Zpoint3,Xpoint3,Ypoint3, ZPoint3,XPoint3,YPoint3;
std::vector<int> Nhits,truthpdg,ppe;
std::vector<double> truth_gene;
std::vector<double> truth_productiony;
std::vector<double> truth_dtmin;
std::vector<double> truth_mindt;
std::vector<double> truth_dt;
std::vector<double> truth_min;

t8->SetBranchAddress( "TruthEndY2", &TruthEndY2);
t8->SetBranchAddress( "TruthEndZ2", &TruthEndZ2);
t8->SetBranchAddress( "TruthEndX2", &TruthEndX2);
t8->SetBranchAddress( "TruthEnergy2", &TruthEnergy2);
t8->SetBranchAddress( "Completeness",&Completeness);
t8->SetBranchAddress( "PURITY",&PURITY);

t8->SetBranchAddress( "EVERYTRACK_TRUTH_STARTPOINTX22", &EVERYTRACK_TRUTH_STARTPOINTX22);
t8->SetBranchAddress( "TruthStartY2", &TruthStartY2);
t8->SetBranchAddress( "TruthStartZ2", &TruthStartZ2);
t8->SetBranchAddress( "EVERYTRACK_TRUTH_PDG2", &EVERYTRACK_TRUTH_PDG2);
t8->SetBranchAddress( "EVERYTRACK_ANGLE2", &EVERYTRACK_ANGLE2);
t8->SetBranchAddress( "EVERYTRACK_PHI2", &EVERYTRACK_PHI2);
t8->SetBranchAddress( "ZENITH2", &ZENITH2);
t8->SetBranchAddress( "AZIMUTH2", &AZIMUTH2);
t8->SetBranchAddress( "EVERYTRACK_STARTY2", &EVERYTRACK_STARTY2);
t8->SetBranchAddress( "EVERYTRACK_ENDY2", &EVERYTRACK_ENDY2);

t8->SetBranchAddress("event", &event);

t8->SetBranchAddress( "EVERYTRACK_THETAYZ", &EVERYTRACK_THETAYZ);
t8->SetBranchAddress( "EVERYTRACK_THETAXZ", &EVERYTRACK_THETAXZ);

t8->SetBranchAddress( "Xpoint", &Xpoint);
t8->SetBranchAddress( "Zpoint", &Zpoint);
t8->SetBranchAddress( "Ypoint", &Ypoint);

t8->SetBranchAddress("FIRSTCHANNELTPC",&FIRSTCHANNELTPC);
t8->SetBranchAddress("LASTCHANNELTPC",&LASTCHANNELTPC);

t8->SetBranchAddress( "TO", &TO);
t8->SetBranchAddress( "EVERYTRACK_ENDX2", &EVERYTRACK_ENDX2);
t8->SetBranchAddress( "EVERYTRACK_STARTZ2", &EVERYTRACK_STARTZ2);
t8->SetBranchAddress( "EVERYTRACK_ENDZ2", &EVERYTRACK_ENDZ2);
t8->SetBranchAddress( "EVERYTRACK_STARTX2", &EVERYTRACK_STARTX2);
t8->SetBranchAddress( "EVERYTRACK_LENGTH2", &EVERYTRACK_LENGTH2);

t8->SetBranchAddress("EVERYTRACK_TRUTH_GENE2", &EVERYTRACK_TRUTH_GENE2);
t8->SetBranchAddress("EVERYTRACK_TRUTH_PRODUCTIONY2", &EVERYTRACK_TRUTH_PRODUCTIONY2);
t8->SetBranchAddress("EVERYTRACK_TRUTH_DTMIN2", &EVERYTRACK_TRUTH_DTMIN2);
t8->SetBranchAddress("EVERYTRACK_TRUTH_MINDT2", &EVERYTRACK_TRUTH_MINDT2);
t8->SetBranchAddress("EVERYTRACK_TRUTH_DT2", &EVERYTRACK_TRUTH_DT2);
t8->SetBranchAddress("EVERYTRACK_TRUTH_MIN2", &EVERYTRACK_TRUTH_MIN2);

t1->Branch("minimum_distance2",&minimum_distance2,"minimum_distance2/D");
t1->Branch("angle",&angle,"angle/D");

//t1->Branch("vector_minimum_distance2",&vector_minimum_distance2);
//t1->Branch("vector_angle",&vector_angle);


std::cout << "T8 " << t8->GetEntries()  << std::endl;

int il0=0;
int il1=0;
int il2=0;
int il3=0;
int il4=0;
int il5=0;
int il6=0;
int il7=0;
int il8=0;
int il88=0;
int il99=0;
int c=0;

  for(Int_t iit=0; iit<t8->GetEntries(); iit++){
if (iit%1000==0) cout<<iit<<"/"<<t8->GetEntries()<<endl;  
  t8->GetEntry(iit);

truthpdg.clear();
Costhetaxz.clear();
completeness.clear();
purity.clear();
positive_or_negative.clear();
length2.clear();
theta.clear();
phi.clear();
zenith.clear();
azimuth.clear();
startingx.clear();
startingy.clear();
startingz.clear();
endingx.clear();
endingy.clear();
endingz.clear();
Zpoint3.clear();
Xpoint3.clear();
Ypoint3.clear();
lengthyz.clear();
ZPoint3.clear();
XPoint3.clear();
YPoint3.clear();
Startingx.clear();
Startingy.clear();
Startingz.clear();
Endingx.clear();
Endingy.clear();
Endingz.clear();
ZENITH.clear();
E_truth.clear();
Nhits.clear();
truth_gene.clear();
truth_productiony.clear();
truth_dtmin.clear();
truth_mindt.clear();
truth_dt.clear();
truth_min.clear();

//if(iit==10){

Int_t particles_per_event=0;
Int_t k=0;

if(EVERYTRACK_LENGTH2->size()!=0){


for(Int_t ik=0; ik<EVERYTRACK_LENGTH2->size(); ik++){

//double length = sqrt( ((EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))*(EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))) + ((EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))*(EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))) );
 
 double length3 = sqrt( ((EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))*(EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))) + ((EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))*(EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))) );

double length = sqrt( ((EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))*(EVERYTRACK_STARTY2->at(ik)-EVERYTRACK_ENDY2->at(ik))) + ((EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))*(EVERYTRACK_STARTZ2->at(ik)-EVERYTRACK_ENDZ2->at(ik))) + ((EVERYTRACK_STARTX2->at(ik)-EVERYTRACK_ENDX2->at(ik))*(EVERYTRACK_STARTX2->at(ik)-EVERYTRACK_ENDX2->at(ik))) );

int LastChanneltpc = 0;

for(Int_t it=0; it<FIRSTCHANNELTPC->at(ik).size(); it++){

int Lasttpc = FIRSTCHANNELTPC->at(ik).at(it);
if(!(Lasttpc==2||Lasttpc==3||Lasttpc==6||Lasttpc==7||Lasttpc==10||Lasttpc==11)){
//if(!(Lasttpc==2)){
LastChanneltpc=1;   
}}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//if(EVERYTRACK_TRUTH_PDG2->at(ik)==13||EVERYTRACK_TRUTH_PDG2->at(ik)==-13){

il0= il0+1;
if(LastChanneltpc==0){
il2= il2+1;


fl->Fill(length,length3);

//if(length>15&&length<=450){

if(length<=1140&&length>15){

//Com->Fill(Completeness->at(ik));
//Pur->Fill(PURITY->at(ik));


//einai xz gonia
double cos_theta_xz = pow(EVERYTRACK_ENDZ2->at(ik) - EVERYTRACK_STARTZ2->at(ik),2)/(sqrt(pow(EVERYTRACK_ENDX2->at(ik) - EVERYTRACK_STARTX2->at(ik),2)+pow(EVERYTRACK_ENDZ2->at(ik) - EVERYTRACK_STARTZ2->at(ik),2))*sqrt(pow(EVERYTRACK_ENDZ2->at(ik) - EVERYTRACK_STARTZ2->at(ik),2)));

//einai xy gonia
//double cos_theta_xz = cos(atan2( (EVERYTRACK_ENDX2->at(ik) - EVERYTRACK_STARTX2->at(ik)), (EVERYTRACK_ENDY2->at(ik) - EVERYTRACK_STARTY2->at(ik)) ));


//if((length<=1140&&length>22) || (abs(cos_theta_xz)>0.2 && length>=5 && length<=22)|| length<5  ){




il1= il1+1;

//if(TruthEnergy2->at(ik)>8){
//if(Completeness->at(ik)<0.1){

k=k+1;


startingx.push_back(EVERYTRACK_STARTX2->at(ik));
startingy.push_back(EVERYTRACK_STARTY2->at(ik));
startingz.push_back(EVERYTRACK_STARTZ2->at(ik));

endingx.push_back(EVERYTRACK_ENDX2->at(ik));
endingy.push_back(EVERYTRACK_ENDY2->at(ik));
endingz.push_back(EVERYTRACK_ENDZ2->at(ik));


/*
startingx.push_back(EVERYTRACK_TRUTH_STARTPOINTX22->at(ik));
startingy.push_back(TruthStartY2->at(ik));
startingz.push_back(TruthStartZ2->at(ik));

endingx.push_back(TruthEndX2->at(ik));
endingy.push_back(TruthEndY2->at(ik));
endingz.push_back(TruthEndZ2->at(ik));
*/


/*
Double_t dx_truth = TruthEndX2->at(ik)-EVERYTRACK_TRUTH_STARTPOINTX22->at(ik);
Double_t dy_truth = TruthEndY2->at(ik)-TruthStartY2->at(ik);
Double_t dz_truth = TruthEndZ2->at(ik)-TruthStartZ2->at(ik);

E_truth.push_back(TruthEnergy2->at(ik));
zenith.push_back(std::atan2(sqrt( (dx_truth*dx_truth)+(dz_truth*dz_truth)), -dy_truth)*180/3.14);
*/


Zpoint2.clear();
Xpoint2.clear();
Ypoint2.clear();

//std::cout << "event " << event  << std::endl;

TRandom2 *rad = new TRandom2(1);
t=0;
x=0;
Y=0;
z=0;

for(Int_t i=0;i<800;i++){
 t = rad->Rndm();
 x = EVERYTRACK_STARTX2->at(ik) + ((EVERYTRACK_ENDX2->at(ik)-EVERYTRACK_STARTX2->at(ik))*t) ;
 Y = EVERYTRACK_STARTY2->at(ik) + ((EVERYTRACK_ENDY2->at(ik)-EVERYTRACK_STARTY2->at(ik))*t) ;
 z = EVERYTRACK_STARTZ2->at(ik) + ((EVERYTRACK_ENDZ2->at(ik)-EVERYTRACK_STARTZ2->at(ik))*t) ;

Xpoint2.push_back(x);
Ypoint2.push_back(Y);
Zpoint2.push_back(z);

}

Xpoint3.push_back(Xpoint2);
Ypoint3.push_back(Ypoint2);
Zpoint3.push_back(Zpoint2);

E_truth.push_back(TruthEnergy2->at(ik));
//completeness.push_back(Completeness->at(ik));
//purity.push_back(PURITY->at(ik));
//truthpdg.push_back(EVERYTRACK_TRUTH_PDG2->at(ik));

//Track_Zenith->Fill(ZENITH2->at(ik));

//phi.push_back( std::atan2(EVERYTRACK_ENDY2->at(ik)-EVERYTRACK_STARTY2->at(ik), EVERYTRACK_ENDX2->at(ik)-EVERYTRACK_STARTX2->at(ik))*180/3.14);


Double_t dxx = EVERYTRACK_ENDX2->at(ik)-EVERYTRACK_STARTX2->at(ik) ;
Double_t dyy = EVERYTRACK_ENDY2->at(ik)-EVERYTRACK_STARTY2->at(ik);
Double_t dzz = EVERYTRACK_ENDZ2->at(ik)-EVERYTRACK_STARTZ2->at(ik);


Costhetaxz.push_back(cos_theta_xz);
Nhits.push_back(FIRSTCHANNELTPC->at(ik).size());



// this is the best zenith!!!!!!
//zenith.push_back(std::atan2(sqrt( (dxx*dxx)+(dzz*dzz)), -dyy)*180/3.14);
///////////////////////////////////////////////////////////////////////////


truth_gene.push_back(EVERYTRACK_TRUTH_GENE2->at(ik));
truth_productiony.push_back(EVERYTRACK_TRUTH_PRODUCTIONY2->at(ik));
truth_dtmin.push_back(EVERYTRACK_TRUTH_DTMIN2->at(ik));
truth_mindt.push_back(EVERYTRACK_TRUTH_MINDT2->at(ik));
truth_dt.push_back(EVERYTRACK_TRUTH_DT2->at(ik));
truth_min.push_back(EVERYTRACK_TRUTH_MIN2->at(ik));

///////////////////////////////////////////////////////////////////////////

zenith.push_back(ZENITH2->at(ik));
azimuth.push_back(AZIMUTH2->at(ik));
length2.push_back(EVERYTRACK_LENGTH2->at(ik));
phi.push_back(EVERYTRACK_PHI2->at(ik));
theta.push_back(EVERYTRACK_ANGLE2->at(ik));
lengthyz.push_back(length);
positive_or_negative.push_back(LastChanneltpc);

//COSMIC_8905_->Fill( std::atan2(sqrt( (dx*dx)+(dy*dy)), dz)*180/3.14 );
//COSMIC_8903_->Fill( std::atan2(sqrt( (dx*dx)+(dz*dz)), -dy)*180/3.14 );

}}}
//}}}}}}
}

//std::cout<<"////////////"<<std::endl;


std::vector<int> v; 
v.clear();
v = { -1 };
std::vector<int> v0;
v0.clear();
v0 = { -1 };


if(startingx.size()!=0){

vector_angle.clear();
vector_minimum_distance2.clear();

Int_t ik=0;

for(ik;ik<startingx.size();ik++){

Double_t broken = 0;
Double_t dx = endingx.at(ik)-startingx.at(ik);
Double_t dy = endingy.at(ik)-startingy.at(ik);
Double_t dz = endingz.at(ik)-startingz.at(ik);
Double_t range= sqrt((dx*dx)+(dy*dy)+(dz*dz) );

/*
for(Int_t ill=0;ill<startingx.size();ill++){
if(ill!=ik){
if( !(std::find(v0.begin(), v0.end(), ill) != v0.end()) ) {
Double_t ddx2 = endingx.at(ill)-startingx.at(ill);
Double_t ddy2 = endingy.at(ill)-startingy.at(ill);
Double_t ddz2 = endingz.at(ill)-startingz.at(ill);
Double_t drange2= sqrt((ddx2*ddx2)+(ddy2*ddy2)+(ddz2*ddz2) );

Double_t dax = startingx.at(ik) - startingx.at(ill);
Double_t day = startingy.at(ik) - startingy.at(ill);
Double_t daz = startingz.at(ik) - startingz.at(ill);

Double_t dbx= (dy*ddz2)-(dz*ddy2);
Double_t dby=-((dx*ddz2)-(dz*ddx2));
Double_t dbz=(dx*ddy2)-(dy*ddx2);

Double_t metro2 = sqrt((dbx*dbx) + (dby*dby) + (dbz*dbz)) ;
minimum_distance2 = TMath::Abs((dax*dbx) + (day*dby) + (daz*dbz)) /metro2;

Double_t ox= dx*ddx2;
Double_t oz= dz*ddz2;
Double_t oy= dy*ddy2;
Double_t costheta2 = (ox+oy+oz)/(range*drange2);

v0.push_back(ik);

vector_angle.push_back(abs(costheta2));
vector_minimum_distance2.push_back(minimum_distance2);
f2D->Fill(minimum_distance2,abs(costheta2));
f2Dss->Fill(minimum_distance2,abs(costheta2));

 angle = abs(costheta2);

if(!(angle>=0.96&&minimum_distance2<=12)){
//if(!(minimum_distance2<=12)){


TCOSMIC_8904_2->Fill(minimum_distance2);
TCOSMIC_8904_1->Fill(minimum_distance2);
//f2D->Fill(minimum_distance2,abs(costheta2));
Angle->Fill(abs(costheta2));
Angle2->Fill(abs(costheta2));
}

t1->Fill();

if(minimum_distance2>200){
TCOSMIC_8904_3->Fill(minimum_distance2);
}
}}}

*/

if( !(std::find(v.begin(), v.end(), ik) != v.end()) ) {

for(Int_t iz=0;iz<startingx.size();iz++){
if(iz!=ik){
 
Double_t dx2 = endingx.at(iz)-startingx.at(iz);
Double_t dy2 = endingy.at(iz)-startingy.at(iz);
Double_t dz2 = endingz.at(iz)-startingz.at(iz);
Double_t range2= sqrt((dx2*dx2)+(dy2*dy2)+(dz2*dz2) );

Double_t ax = startingx.at(ik) - startingx.at(iz);
Double_t ay = startingy.at(ik) - startingy.at(iz);
Double_t az = startingz.at(ik) - startingz.at(iz);

Double_t bx= (dy*dz2)-(dz*dy2);
Double_t by=-((dx*dz2)-(dz*dx2));
Double_t bz=(dx*dy2)-(dy*dx2);

Double_t metro = sqrt((bx*bx) + (by*by) + (bz*bz)) ;
Double_t minimum_distance = TMath::Abs((ax*bx) + (ay*by) + (az*bz)) /metro;

Double_t x= dx*dx2;
Double_t z= dz*dz2;
Double_t y= dy*dy2;
Double_t costheta = (x+y+z)/(range*range2);


if(abs(costheta)>=0.96){

if(minimum_distance<=12){

broken=1;
v.push_back(iz);



//for(Int_t iim=0;iim<Xpoint3.at(iz).size();iim++){

//fffms->Fill(Xpoint3.at(iz).at(iim),Ypoint3.at(iz).at(iim),Zpoint3.at(iz).at(iim));

//}


}}}}} // end of the second loop


 if(broken==1){


v.push_back(ik);
} 

}}//end of the first loop

//Int_t particles_per_event=0;

for(Int_t il=0;il<startingx.size();il++){
if( !(std::find(v.begin(), v.end(), il) != v.end()) ) {

il3= il3+1;

//if(positive_or_negative.at(il)==0){
//if(lengthyz.at(il)<=20){ // use it for persentage studies with different lengths
//if(lengthyz.at(il)>15&&lengthyz.at(il)<=1140){
//il1= il1+1;

//Com->Fill(completeness.at(il));
//Pur->Fill(purity.at(il));

if(phi.at(il)<-10&&phi.at(il)>-170){
il4= il4+1;

//if(angleyz<-10&&angleyz>-170){

double dy = endingy.at(il)-startingy.at(il);
double dz = endingz.at(il)-startingz.at(il);
double angleyz = (std::atan2(dy,dz)*180/3.14);


//if((lengthyz.at(il)<=1140&&lengthyz.at(il)>100) || (abs(angleyz)>0.7 && lengthyz.at(il)>=5 && lengthyz.at(il)<=100)|| lengthyz.at(il)<5  ){

if((lengthyz.at(il)<=1140&&lengthyz.at(il)>22) || (abs(Costhetaxz.at(il))>0.2 && lengthyz.at(il)>=5 && lengthyz.at(il)<=22)|| lengthyz.at(il)<5  ){

//if((lengthyz.at(il)<=1140&&lengthyz.at(il)>20) || ( phi.at(il)<-20 && lengthyz.at(il)>=5 && lengthyz.at(il)<=20)|| lengthyz.at(il)<5  ){
//if(!( azimuth.at(il)>-20 && azimuth.at(il)<50 && lengthyz.at(il)>=5 && lengthyz.at(il)<=40    )  ){

il7= il7+1;

//if( abs(endingy.at(il)) - abs(startingx.at(il))<=360 ){
//if(startingy.at(il)<=580&&startingy.at(il)>=0&&endingy.at(il)<=600&&endingy.at(il)>=0){

//if(completeness.at(il)>=0.8) il88= il88+1;
//if(purity.at(il)>=0.8) il99= il99+1;


if(startingy.at(il)<=600&&startingy.at(il)>=0&&endingy.at(il)<=600&&endingy.at(il)>=0){
il5= il5+1;

if((startingz.at(il)>=4&&startingz.at(il)<224)||(startingz.at(il)>237&&startingz.at(il)<456)||(startingz.at(il)>472&&startingz.at(il)<=688)){
if((endingz.at(il)>=4&&endingz.at(il)<224)||(endingz.at(il)>237&&endingz.at(il)<456)||(endingz.at(il)>472&&endingz.at(il)<=688)){
if(!((endingz.at(il)>56&&endingz.at(il)<60)||(endingz.at(il)>280&&endingz.at(il)<286)||(endingz.at(il)>520&&endingz.at(il)<526))){
if(!((startingz.at(il)>56&&startingz.at(il)<60)||(startingz.at(il)>280&&startingz.at(il)<286)||(startingz.at(il)>520&&startingz.at(il)<526))){

il6= il6+1;


/*
if((startingz.at(il)>=0&&startingz.at(il)<224)||(startingz.at(il)>237&&startingz.at(il)<456)||(startingz.at(il)>472&&startingz.at(il)<=690)){
if((endingz.at(il)>=0&&endingz.at(il)<224)||(endingz.at(il)>237&&endingz.at(il)<456)||(endingz.at(il)>472&&endingz.at(il)<=690)){
if(!((endingz.at(il)>56&&endingz.at(il)<60)||(endingz.at(il)>280&&endingz.at(il)<286)||(endingz.at(il)>520&&endingz.at(il)<526))){
if(!((startingz.at(il)>56&&startingz.at(il)<60)||(startingz.at(il)>280&&startingz.at(il)<286)||(startingz.at(il)>520&&startingz.at(il)<526))){
*/


/*

if((startingz.at(il)<224)||(startingz.at(il)>237&&startingz.at(il)<456)||(startingz.at(il)>472)){
if( (endingz.at(il)<224)||(endingz.at(il)>237&&endingz.at(il)<456)||(endingz.at(il)>472)){ 
if(!((endingz.at(il)>56&&endingz.at(il)<60)||(endingz.at(il)>280&&endingz.at(il)<286)||(endingz.at(il)>520&&endingz.at(il)<526))){
if(!((startingz.at(il)>56&&startingz.at(il)<60)||(startingz.at(il)>280&&startingz.at(il)<286)||(startingz.at(il)>520&&startingz.at(il)<526))){
*/


//if(abs(truthpdg.at(il))==11||truthpdg.at(il)==22) il8= il8+1;
//if(abs(truthpdg.at(il))==13) il5= il5+1;

//if(completeness.at(il)>=0.8) il88= il88+1;
//if(purity.at(il)>=0.8) il99= il99+1;

particles_per_event = particles_per_event +1;

/*
if(Nhits.at(il)>120) il7= il7+1;
if(Nhits.at(il)>70) il7= il7+1;
if(Nhits.at(il)>60) il6= il6+1;
if(Nhits.at(il)>50) il8= il8+1;
if(Nhits.at(il)>40) il5= il5+1;
if(Nhits.at(il)>30) il5= il5+1;
*/

ZPoint2.clear();
XPoint2.clear();
YPoint2.clear(); 

for(Int_t iim=0;iim<Xpoint3.at(il).size();iim++){

fffms->Fill(Xpoint3.at(il).at(iim),Ypoint3.at(il).at(iim),Zpoint3.at(il).at(iim));

XPoint2.push_back(Xpoint3.at(il).at(iim));
YPoint2.push_back(Ypoint3.at(il).at(iim));
ZPoint2.push_back(Zpoint3.at(il).at(iim));

}

XPoint3.push_back(XPoint2);
YPoint3.push_back(YPoint2);
ZPoint3.push_back(ZPoint2);

ZENITH.push_back(zenith.at(il));

Startingx.push_back(startingx.at(il));
Startingy.push_back(startingy.at(il));
Startingz.push_back(startingz.at(il));

Endingx.push_back(endingx.at(il));
Endingy.push_back(endingy.at(il));
Endingz.push_back(endingz.at(il));



//f22ms->Fill(phi.at(il),zenith.at(il));
//f22ms->Fill(azimuth.at(il),zenith.at(il));

f2ms->Fill(startingy.at(il),startingz.at(il));
f2me->Fill(endingy.at(il),endingz.at(il));


//if(Nhits.at(il)<50) HITS->Fill(Nhits.at(il));
 HITS->Fill(Nhits.at(il));
HITS2->Fill(Nhits.at(il)/lengthyz.at(il));

Cos->Fill(abs(Costhetaxz.at(il)));

//PDG->Fill(truthpdg.at(il));
//Com->Fill(completeness.at(il));
//Pur->Fill(purity.at(il));

COSMIC_8901->Fill(azimuth.at(il));
Track_Zenith->Fill(zenith.at(il));
Track_Length->Fill(lengthyz.at(il));
COSMIC_8905->Fill(theta.at(il));
Track_Phi->Fill(phi.at(il));
Track_AngleYZ->Fill(angleyz);


COSMIC_8907->Fill(startingx.at(il));
COSMIC_8908->Fill(endingx.at(il));

Track_StartY->Fill(startingy.at(il));
Track_EndY->Fill(endingy.at(il));
Track_StartZ->Fill(startingz.at(il));
Track_EndZ->Fill(endingz.at(il));


////////////////////////////////////////////////////////////////////////////////////////////////////////
if(truth_gene.at(il)>0){
Track_Truth_Gene->Fill(truth_gene.at(il));
Track_Truth_ProductionY->Fill(truth_productiony.at(il));
Track_Truth_DTMin->Fill(truth_dtmin.at(il));
Track_Truth_MinDT->Fill(truth_mindt.at(il));
Track_Truth_DT->Fill(truth_dt.at(il));
Track_Truth_Min->Fill(truth_min.at(il));
E_TRUTH->Fill(E_truth.at(il));

if(truth_gene.at(il)!= 52 && truth_dtmin.at(il)<=300 && truth_dt.at(il)<=6 ){
//if(truth_gene.at(il)!= 52 && truth_dtmin.at(il)<=100 && truth_dt.at(il)<=1 ){
//if(truth_gene.at(il)!= 52 ){
h2_min_dt0->Fill(truth_dtmin.at(il),truth_dt.at(il));

 //h2_min_dt1->Fill(truth_min.at(il),truth_mindt.at(il));
 Track_Truth_ProductionY50->Fill(truth_productiony.at(il));
 h2_min_dt1->Fill(truth_dtmin.at(il),truth_dt.at(il));
 E_TRUTH50->Fill(E_truth.at(il));
}
//else{
if(truth_gene.at(il) == 52 && !(truth_dtmin.at(il) <= 300 && truth_dt.at(il) <= 6)){
//if(truth_gene.at(il)== 52 ){
//h2_min_dt2->Fill(truth_min.at(il),truth_mindt.at(il));
 Track_Truth_ProductionY52->Fill(truth_productiony.at(il));
 h2_min_dt2->Fill(truth_dtmin.at(il),truth_dt.at(il));
 E_TRUTH52->Fill(E_truth.at(il));
}

//h2_min_dt3->Fill(truth_dtmin.at(il),truth_dt.at(il));
//h2_min_dt3->Fill(truth_dtmin.at(il),truth_dt.at(il));

}
///////////////////////////////////////////////////////////////////////


}}}}}
}}
}}// looping to the unbroken tracks
Track_Multiplicity->Fill(particles_per_event);

////////////////////////////// Lets Study the angle between tracks (in order to select an angle for the cone)///////////////////////////////////////

for(Int_t ik=0;ik<Startingx.size();ik++){

Double_t dx = Endingx.at(ik)-Startingx.at(ik);
Double_t dy = Endingy.at(ik)-Startingy.at(ik);
Double_t dz = Endingz.at(ik)-Startingz.at(ik);

Double_t range= sqrt((dx*dx)+(dy*dy)+(dz*dz) );


for(Int_t iz=0;iz<Startingx.size();iz++){
if(iz>ik){

Double_t dx2 = Endingx.at(iz)-Startingx.at(iz);
Double_t dy2 = Endingy.at(iz)-Startingy.at(iz);
Double_t dz2 = Endingz.at(iz)-Startingz.at(iz);

Double_t x= dx*dx2;
Double_t z= dz*dz2;
Double_t y= dy*dy2;
Double_t range2= sqrt((dx2*dx2)+(dy2*dy2)+(dz2*dz2) );
Double_t costheta = (x+y+z)/(range*range2);


Angle->Fill(abs(costheta));
Angle2->Fill(abs(costheta));
}}}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

std::vector<int> v1;
std::vector<int> COUNTER;
int counter;

v1.clear();
v1 = { -1 };
COUNTER.clear();
ZENITH_PARALLEL.clear();

if(Startingx.size()!=0){

Int_t ik=0;
 
for(ik;ik<Startingx.size();ik++){

if( !(std::find(v1.begin(), v1.end(), ik) != v1.end()) ) {
 
Double_t parallel=0;

Double_t dx = Endingx.at(ik)-Startingx.at(ik);
Double_t dy = Endingy.at(ik)-Startingy.at(ik);
Double_t dz = Endingz.at(ik)-Startingz.at(ik);

Double_t range= sqrt((dx*dx)+(dy*dy)+(dz*dz) );
 
counter=0;
for(Int_t iz=0;iz<Startingx.size();iz++){
if(ik!=iz){

Double_t dx2 = Endingx.at(iz)-Startingx.at(iz);
Double_t dy2 = Endingy.at(iz)-Startingy.at(iz);
Double_t dz2 = Endingz.at(iz)-Startingz.at(iz);

Double_t x= dx*dx2;
Double_t z= dz*dz2;
Double_t y= dy*dy2;
Double_t range2= sqrt((dx2*dx2)+(dy2*dy2)+(dz2*dz2) );
Double_t costheta = (x+y+z)/(range*range2);

//std::cout<<"ik= "<< ik << " iz= "<< iz<< " costheta= "<< costheta <<std::endl;

if(abs(costheta)>=0.992){
//if(abs(costheta)>=0.996){

v1.push_back(iz);

parallel=1;
counter= counter+1;
//for(Int_t iim=0;iim<XPoint3.at(iz).size();iim++){
//fffms->Fill(XPoint3.at(iz).at(iim),YPoint3.at(iz).at(iim),ZPoint3.at(iz).at(iim));
//}

//////////////////////////////////////////////////////////////////////////////////
// here u can see the distributions of multi muons

//COSMIC_8903->Fill(ZENITH.at(iz));

ZENITH_PARALLEL.push_back(ZENITH.at(iz));

}}} // end of the second loop


 if(parallel==1){

////////////////////////////////////////////////////////////////////////////////////
// here u can see the distributions of multi muons

//for(Int_t im=0;im<XPoint3.at(ik).size();im++){
//fffms->Fill(XPoint3.at(ik).at(im),YPoint3.at(ik).at(im),ZPoint3.at(ik).at(im));   
//}
  
//COSMIC_8903->Fill(ZENITH.at(ik));
ZENITH_PARALLEL.push_back(ZENITH.at(ik));

v1.push_back(ik);

}


/////////////////////////////////////////////////////////

// I repeat the process to find all the track in the cone

/////////////////////////////////////////////////////////

int size_vector = v1.size() -1;


if(v1.size()>1){
for(Int_t ikl=0;ikl<Startingx.size();ikl++){

if( std::find(v1.begin(), v1.end(), ikl) != v1.end())  {
if(ikl!=v1.at(size_vector) ){

Double_t dxa = Endingx.at(ikl)-Startingx.at(ikl);
Double_t dya = Endingy.at(ikl)-Startingy.at(ikl);
Double_t dza = Endingz.at(ikl)-Startingz.at(ikl);

Double_t rangea= sqrt((dxa*dxa)+(dya*dya)+(dza*dza) );

for(Int_t iz=0;iz<Startingx.size();iz++){
if( !(std::find(v1.begin(), v1.end(), iz) != v1.end()))  {

Double_t dx2 = Endingx.at(iz)-Startingx.at(iz);
Double_t dy2 = Endingy.at(iz)-Startingy.at(iz);
Double_t dz2 = Endingz.at(iz)-Startingz.at(iz);

Double_t x= dxa*dx2;
Double_t z= dza*dz2;
Double_t y= dya*dy2;
Double_t range2= sqrt((dx2*dx2)+(dy2*dy2)+(dz2*dz2) );
Double_t costheta = (x+y+z)/(rangea*range2);

//std::cout<<"ikl= "<< ikl << " iz= "<< iz<< " costheta= "<< costheta <<std::endl;

if(abs(costheta)>=0.992){

counter= counter+1;
v1.push_back(iz);
if(ikl>iz) ikl = iz;

}}}}}}} // loop over the particles on the cone just to be sure


if(counter>0){
counter= counter+1;
COUNTER.push_back(counter);
Parallel_per_cone->Fill(counter);
}

} // end of the if statement !(std::find(v.begin(), v.end(), ik) != v.end())
} //end of the first loop
}//Startingx.size()!=0 statement
//}// if ik= 20


Int_t sum_of_elems = std::accumulate(COUNTER.begin(), COUNTER.end(),decltype(COUNTER)::value_type(0));
/*
std::cout<<"number of tracks= "<< Startingx.size() << std::endl;
std::cout<<"number of parallel tracks= " << sum_of_elems <<std::endl;
std::cout<<"number of single muons= " << Startingx.size()-sum_of_elems <<std::endl;
std::cout<<"number of air showers= "<< COUNTER.size()<<std::endl;
*/

 Counter->Fill(sum_of_elems);
//if(sum_of_elems!=0) Counter->Fill(sum_of_elems);
Air->Fill(COUNTER.size());
Single->Fill(Startingx.size()-sum_of_elems);
 
//if(Startingx.size()-sum_of_elems>1000) std::cout<<"problematic event= "<< iit <<std::endl;

//}// 10th event
////////////////////////////////////////////// CHECKING THE RUN BY COUNTING THE NUMBER OF PFPartiecles per 20 events
ppe.push_back(particles_per_event);

if (iit%100==0&&iit!=0){
Int_t sum_elems = std::accumulate(ppe.begin(), ppe.end(),decltype(ppe)::value_type(0));
c=c+1;
ppe.clear();
particl.push_back(sum_elems);
eve.push_back(c);
exl.push_back(0);      
eyl.push_back(sqrt(sum_elems));
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}// event loop


std::cout<<"Multi Events= "<<Counter->GetEntries()<<std::endl;

std::cout<<"All together Mean= "<< Track_Multiplicity->GetMean() << " Error Mean= "<< Track_Multiplicity->GetStdDev()/sqrt(Track_Multiplicity->GetEntries())  <<std::endl;
std::cout<<"Air Showers Mean= " << Air->GetMean() << " Error Mean= "<< Air->GetStdDev()/sqrt(Air->GetEntries())   <<std::endl;
std::cout<<"Multi-muons Mean= " << Counter->GetMean() << " Error Mean= "<< Counter->GetStdDev()/sqrt(Counter->GetEntries())   <<std::endl;
std::cout<<"Single Mean= "      << Single->GetMean() << " Error Mean= "<< Single->GetStdDev()/sqrt(Single->GetEntries())   <<std::endl;

std::cout<<"Zenith Mean= "<< Track_Zenith->GetMean() << " Error Mean= "<< Track_Zenith->GetStdDev()/sqrt(Track_Zenith->GetEntries())  <<std::endl;

std::cout<<"Integral Zenith= "<<Track_Zenith->Integral()<<std::endl;
std::cout<<"Integral Theta= "<<COSMIC_8905->Integral()<<std::endl;
std::cout<<"Integral Azimuth= "<<COSMIC_8901->Integral()<<std::endl;
std::cout<<"Integral Phi= "<<Track_Phi->Integral()<<std::endl;
std::cout<<"Integral lENGTH= "<<Track_Length->Integral()<<std::endl;
std::cout<<"Integral StartY= "<<Track_StartY->Integral()<<std::endl;
std::cout<<"Integral StartZ= "<<Track_StartZ->Integral()<<std::endl;
std::cout<<"Integral EndY= "<<Track_EndY->Integral()<<std::endl;
std::cout<<"Integral EndZ= "<<Track_EndZ->Integral()<<std::endl;
std::cout<<"Integral Track_AngleYZ= "<<Track_AngleYZ->Integral()<<std::endl;
std::cout<<"Integral Cos= "<<Cos->Integral()<<std::endl;

std::cout<<"Number of tracks = "<< il0 <<std::endl;
std::cout<<"Number of tracks due to X>0 = "<< il2 <<std::endl;
std::cout<<"Number of tracks due to length cut = "<< il1 <<std::endl;
std::cout<<"Number of tracks due to broken cut = "<< il3 <<std::endl;
std::cout<<"Number of tracks due to Angular cut = "<< il4 <<std::endl;
std::cout<<"Number of tracks due to Angular cut 2 = "<< il7 <<std::endl;
std::cout<<"Number of tracks due to Y<600 = "<< il5 <<std::endl;
std::cout<<"Number of tracks due to Z cut = "<< il6 <<std::endl;

std::cout<<"Number of tracks for completeness>0.8 = "<< il88 <<std::endl;
std::cout<<"Number of tracks for purity>0.8 = "<< il99 <<std::endl;


// For Data
// exo allaksei to order broken-me length cut

//Îumber of tracks
double v0= il0;  //all together (no cuts applied)
double v1= il2;   // x>0
double v2= il1;   // length cut
double v3= il3;   // broken track removal
double v4= il4;   // angular cut
double v5= il7;   // angular cut2
double v6= il5;  // Z  cut
double v7= il6;  // Z  cut


const Int_t nn = 8;

   Double_t y[nn]  = {v0, v1, v2, v3, v4, v5, v6, v7};


// For Absolute Efficiency
std::cout<<" Absolute Efficiency "<<std::endl; 

for(Int_t i=0; i<nn; i++){
if(i!=0){

double efficiency = y[i]/y[0]; 
double lower_error = efficiency - TEfficiency::ClopperPearson(y[0], y[i],  0.683,  false);
double upper_error = TEfficiency::ClopperPearson(y[0], y[i],  0.683,  true) - efficiency; 

std::cout << std::fixed << std::setprecision(2);
std::cout<<" "<< efficiency*100<<" +/- "<<lower_error *100 <<std::endl;

}}

std::cout<<"/////////"<<std::endl;


// For Relative Efficiency
std::cout<<" Relative Efficiency "<<std::endl; 

for(Int_t i=0; i<nn; i++){
if(i!=0){

double efficiency = y[i]/y[i-1]; 
double lower_error = efficiency - TEfficiency::ClopperPearson(y[i-1], y[i],  0.683,  false);
double upper_error = TEfficiency::ClopperPearson(y[i-1], y[i],  0.683,  true) - efficiency; 

std::cout << std::fixed << std::setprecision(2);
std::cout<<" "<< efficiency*100<<" +/- "<<lower_error *100 <<std::endl;


}}



fffms->SetLineColor(kRed);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/*

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//I added a zero at the beginning of the vector because the TH1F doent have zero bin but the vector has a value at  [0]
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//   const Int_t n = 31; 

//   Double_t x_108[n] = {0,1.01245, 0.852796, 0.974408, 0.971816, 0.983522, 1.02882, 0.950123, 1.04726, 0.9974, 1.04706, 1.03646, 0.993851, 0.987708, 1.00116, 0.988699, 0.998999, 1.04292, 1.0048, 0.984946, 1.01223, 0.929693, 0.988284, 0.965784, 0.997124, 1.00267, 1.07313, 1.1119, 0.691736, 0.32281, 0.96843};
//   Double_t x_92[n]  = {0,0.705215, 1.16973, 1.11539, 1.01679, 1.02844, 0.988694, 0.963119, 0.950833, 1.0183, 0.96851, 1.00069, 0.988808, 0.992797, 1.05782, 0.972032, 1.01751, 0.994966, 0.973621, 0.96129, 1.01509, 0.971853, 1.07033, 1.07457, 1.0114, 1.05207, 1.00484, 0.996131, 1.20773, 0.733263, 0.977684};

const Int_t n = 15;
Double_t x_108[n] = {0,0.838064, 0.985199, 1.02758, 0.993759, 1.02836, 1.01416, 0.993584, 0.989753, 1.0266, 1.00789, 0.942891, 0.988132, 1.00419, 1.00144};
Double_t x_92[n]  = {0,1.09332, 1.01276, 1.00291, 0.959284, 0.995893, 0.989045, 1.01983, 0.999071, 0.987461, 0.974507, 1.02641, 1.05175, 1.02831, 1.01219};

for(int xx=1; xx <= Track_Zenith->GetNbinsX(); xx++){

double a222  =  Track_Zenith->GetBin(xx);

double ac  =  Track_Zenith->GetBinContent(a222);
double ac2 =  Track_Zenith->GetBinError(a222);


double error_108SCE = abs(1-x_108[xx])*ac;
double error_92SCE  = abs(1-x_92[xx])*ac;

if(x_108[xx]==0){
 error_108SCE   = 0;
}

if(x_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_Zenith_Systematics->SetBinContent(a222,ac);
Track_Zenith_Systematics->SetBinError(a222,error);

Track_Zenith_Only_Systematics->SetBinContent(a222,ac);
Track_Zenith_Only_Systematics->SetBinError(a222,error2);

Track_Zenith_Noerror->SetBinContent(a222,ac);
Track_Zenith_Noerror->SetBinError(a222,0);

}




   const Int_t n2 = 16;

   Double_t x2_92[n2]   ={0,0, 0, 0.616001, 0.617639, 1.03773, 0.919287, 1.0151, 0.941536, 1.15989, 1.25478, 1.07424, 1.1011, 0.4004, 2.002, 0};
   Double_t x2_108[n2]  ={0,0, 0, 0.625626, 1.13907, 0.823833, 1.03066, 0.829534, 1.04842, 1.03528, 1.23719, 1.092, 1.183, 1.75175, 3.50351, 0};



for(int xx=1; xx <= Track_Multiplicity->GetNbinsX(); xx++){

double a222  =  Track_Multiplicity->GetBin(xx);

double ac  =  Track_Multiplicity->GetBinContent(a222);
double ac2 =  Track_Multiplicity->GetBinError(a222);


double error_108SCE = abs(1-x2_108[xx])*ac;
double error_92SCE  = abs(1-x2_92[xx])*ac;

if(x2_108[xx]==0){
 error_108SCE   = 0;
}

if(x2_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );

if(xx==9){

 std::cout<< "ac= " << ac <<std::endl;
 std::cout<< "x2_92[xx]= " << x2_92[xx] <<std::endl;
 std::cout<< "x2_108[xx]= " << x2_108[xx] <<std::endl;

 std::cout<< "error_92SCE= " << error_92SCE <<std::endl;
 std::cout<< "error_108SCE= " << error_108SCE <<std::endl;
 std::cout<< "error2= " << error2 <<std::endl;
 
}

Track_Multiplicity_Systematics->SetBinContent(a222,ac);
Track_Multiplicity_Systematics->SetBinError(a222,error);

Track_Multiplicity_Only_Systematics->SetBinContent(a222,ac);
Track_Multiplicity_Only_Systematics->SetBinError(a222,error2);

Track_Multiplicity_Noerror->SetBinContent(a222,ac);
Track_Multiplicity_Noerror->SetBinError(a222,0);

}


   const Int_t n3 = 54;

 Double_t x3_108[n3] = {0,0, 1.01109, 0.961842, 0.996099, 1.00253, 1.00219, 1.06583, 0.970275, 1.04808, 0.956547, 1.01642, 1.00861, 0.979717, 1.05286, 0.948666, 1.01726, 0.997857, 0.987174, 1.03847, 0.90865, 0.99967, 0.984844, 1.0254, 0.953298, 1.0014, 1.04556, 1.0474, 1.07724, 1.02391, 0.887727, 0.974678, 1.02113, 0.947224, 1.08141, 0.950661, 0.957299, 1.17595, 1.09221, 0.963138, 0.96843, 0.960492, 1.05192, 0.980098, 0.938167, 0.868739, 1.10401, 0.893935, 1.10049, 1.03299, 1.08948, 0.96843, 0, 0};   
 Double_t x3_92[n3]  = {0,0, 0.941587, 1.03247, 0.997808, 0.989883, 1.04683, 0.937778, 1.03276, 1.00376, 1.05306, 0.988819, 1.03653, 0.964198, 0.995553, 1.02201, 1.01169, 1.02884, 0.97454, 0.947876, 1.01529, 1.04152, 0.964604, 1.03879, 1.01331, 0.986076, 0.986413, 1.02613, 0.89705, 1.00383, 1.02914, 0.965229, 1.05676, 1.06304, 0.938576, 0.934803, 1.11919, 0.989463, 1.15073, 1.01083, 0.964819, 1.02825, 1.12288, 0.922134, 1.06054, 1.10804, 0.958513, 0.996854, 1.13205, 0.888803, 0.977684, 0.977684, 0, 0};


for(int xx=1; xx <= Track_Length->GetNbinsX(); xx++){

double a222  =  Track_Length->GetBin(xx);

double ac  =  Track_Length->GetBinContent(a222);
double ac2 =  Track_Length->GetBinError(a222);


double error_108SCE = abs(1-x3_108[xx])*ac;
double error_92SCE  = abs(1-x3_92[xx])*ac;

if(x3_108[xx]==0){
 error_108SCE   = 0;
}

if(x3_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_LengthYZ_Systematics->SetBinContent(a222,ac);
Track_LengthYZ_Systematics->SetBinError(a222,error);

Track_LengthYZ_Only_Systematics->SetBinContent(a222,ac);
Track_LengthYZ_Only_Systematics->SetBinError(a222,error2);

Track_LengthYZ_Noerror->SetBinContent(a222,ac);
Track_LengthYZ_Noerror->SetBinError(a222,0);

}



   const Int_t n4 = 34;

Double_t x4_108[n4] = {0,0, 0.96843, 0.990847, 0.98405, 1.00568, 0.960176, 0.937642, 1.02772, 0.990192, 1.03419, 0.991217, 0.962016, 0.90134, 1.00008, 0.965365, 0.973751, 1.017, 1.01893, 1.0059, 
0.98552, 0.997299, 0.962943, 0.977832, 1.05671, 0.934587, 0.963774, 1.03844, 1.00974, 0.972569, 0.966493, 1.03605, 0, 0};


Double_t x4_92[n4]  = {0,0, 1.161, 0.914198, 0.990464, 0.960631, 0.994638, 0.994937, 0.918755, 0.974945, 0.974676, 0.96073, 1.00429, 1.03373, 0.961965, 0.993402, 0.954094, 0.965576, 0.986764, 
0.980602, 0.969133, 0.964613, 0.980461, 1.08573, 0.907491, 1.02162, 1.0402, 1.01944, 1.01123, 1.04704, 0.971853, 1.03735, 0,0};



for(int xx=1; xx <= Track_StartY->GetNbinsX(); xx++){

double a222  =  Track_StartY->GetBin(xx);

double ac  =  Track_StartY->GetBinContent(a222);
double ac2 =  Track_StartY->GetBinError(a222);


double error_108SCE = abs(1-x4_108[xx])*ac;
double error_92SCE  = abs(1-x4_92[xx])*ac;

if(x4_108[xx]==0){
 error_108SCE   = 0;
}

if(x4_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_StartY_Systematics->SetBinContent(a222,ac);
Track_StartY_Systematics->SetBinError(a222,error);

Track_StartY_Only_Systematics->SetBinContent(a222,ac);
Track_StartY_Only_Systematics->SetBinError(a222,error2);

Track_StartY_Noerror->SetBinContent(a222,ac);
Track_StartY_Noerror->SetBinError(a222,0);

}




  const Int_t n5 = 34;

Double_t x5_92[n5]  = {0,0, 0.942263, 1.0468, 0.987085, 1.04777, 1.00308, 0.947415, 0.968431, 1.0613, 0.940212, 0.961915, 0.9953, 0.987025, 0.955527, 0.980739, 1.01474, 0.958513, 1.01803, 0.983385, 
1.06712, 1.04879, 0.983161, 1.05687, 1.02715, 1.05966, 1.0473, 0.955836, 1.12764, 0.999532, 1.04076, 0.855473, 0, 0};

Double_t x5_108[n5] = {0,0, 0.948466, 1.01338, 1.06988, 0.99758, 0.931654, 1.01175, 1.13498, 1.00658, 1.02808, 0.930328, 0.988427, 0.947045, 0.988079, 1.01972, 1.00651, 1.08741, 0.950715, 0.9965, 
0.954435, 0.998522, 1.01429, 1.00471, 1.01507, 0.987854, 1.0468, 1.08187, 1.00449, 1.02929, 1.03513, 1.09294, 0, 0};


for(int xx=1; xx <= Track_EndY->GetNbinsX(); xx++){

double a222  =  Track_EndY->GetBin(xx);

double ac  =  Track_EndY->GetBinContent(a222);
double ac2 =  Track_EndY->GetBinError(a222);


double error_108SCE = abs(1-x5_108[xx])*ac;
double error_92SCE  = abs(1-x5_92[xx])*ac;

if(x5_108[xx]==0){
 error_108SCE   = 0;
}

if(x5_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_EndY_Systematics->SetBinContent(a222,ac);
Track_EndY_Systematics->SetBinError(a222,error);

Track_EndY_Only_Systematics->SetBinContent(a222,ac);
Track_EndY_Only_Systematics->SetBinError(a222,error2);

Track_EndY_Noerror->SetBinContent(a222,ac);
Track_EndY_Noerror->SetBinError(a222,0);

}


const Int_t n6 = 56;

   Double_t x6_108[n6] ={0,0, 0.964691, 0.97921, 1.05424, 1.04605, 0.973177, 1.01584, 1.00314, 0.994403, 1.03819, 1.00956, 0.987494, 0.997018, 0.964617, 0.96843, 0.956014, 1.06215, 0.96843, 0.88298, 1.0012, 0.972351, 1.03016, 0.960009, 0.976147, 0.99491, 1.00047, 0.998812, 1.01506, 1.03816, 1.00132, 1.01685, 1.04605, 0.932562, 0.96843, 0.964412, 1.02854, 0.891975, 0.981229, 1.04673, 1.00999, 1.03599, 1.02054, 0.983215, 0.98405, 1.0173, 0.994108, 1.06489, 1.01199, 1.01245, 0.989035, 1.03269, 1.06633, 0.978843, 0.960923, 0};


   Double_t x6_92[n6]  = {0,0, 0.933244, 1.0843, 1.11534, 1.0006, 0.958882, 0.970894, 0.999171, 1.0126, 1.03468, 0.962814, 0.985443, 1.00742, 0.981548, 0.985382, 0.961252, 0.964352, 1.00672, 1.14625, 1.008, 1.02761, 0.993517, 0.952827, 1.03109, 1.01331, 0.988587, 0.977684, 0.977684, 0.94371, 1.02002, 0.998486, 0.996705, 1.12596, 0.977684, 0.977684, 0.991358, 1.19845, 1.01805, 0.915361, 0.990436, 1.02538, 0.947928, 1.06288, 1.02306, 0.991326, 0.966699, 0.973804, 1.02746, 1.06098, 1.03494, 0.991785, 1.1543, 0.947131, 0.970163, 0};




for(int xx=1; xx <= Track_StartZ->GetNbinsX(); xx++){

double a222  =  Track_StartZ->GetBin(xx);

double ac  =  Track_StartZ->GetBinContent(a222);
double ac2 =  Track_StartZ->GetBinError(a222);


double error_108SCE = abs(1-x6_108[xx])*ac;
double error_92SCE  = abs(1-x6_92[xx])*ac;

if(x6_108[xx]==0){
 error_108SCE   = 0;
}

if(x6_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_StartZ_Systematics->SetBinContent(a222,ac);
Track_StartZ_Systematics->SetBinError(a222,error);

Track_StartZ_Only_Systematics->SetBinContent(a222,ac);
Track_StartZ_Only_Systematics->SetBinError(a222,error2);

Track_StartZ_Noerror->SetBinContent(a222,ac);
Track_StartZ_Noerror->SetBinError(a222,0);

}



 const Int_t n7 = 56;

   Double_t x7_108[n7] ={0,0, 1.00032, 1.01734, 1.06988, 0.995331, 0.96843, 0.997876, 0.95229, 0.984411, 1.01594, 0.965032, 1.00759, 0.998459, 0.995546, 1.02089, 0.945908, 0.900337, 0.954917, 1.3558, 0.980145, 0.993171, 0.987054, 1.02849, 0.991039, 1.04665, 1.00241, 1.02582, 1.03228, 1.01859, 1.03573, 1.0269, 1.00929, 0.914841, 1.02724, 0.933532, 1.00656, 1.3409, 1.00071, 1.01726, 0.984571, 1.04409, 0.96843, 0.981458, 0.998905, 0.960292, 0.964632, 1.07097, 1.00315, 1.00343, 0.955907, 1.05292, 1.04998, 0.989236, 0.973296, 0};


   Double_t x7_92[n7]  = {0,0, 0.969284, 1.00824, 1.01306, 1.01529, 1.07755, 1.02622, 1.0149, 0.968099, 1.02406, 0.977684, 0.999737, 0.981488, 0.989559, 0.957731, 1.02956, 0.989277, 0.926, 0.814736, 0.973757, 1.03033, 1.04608, 1.01711, 1.00105, 0.966532, 1.0023, 0.988669, 0.981278, 0.962348, 0.94839, 1.00033, 1.02983, 1.11925, 0.997884, 0.991077, 1.00948, 0.847326, 0.924836, 0.990165, 1.02019, 1.04286, 0.964706, 1.02841, 1.03947, 0.985969, 1.01759, 0.973865, 1.03982, 0.981626, 1.00364, 1.00465, 1.07687, 1.02787, 0.922081, 0};




for(int xx=1; xx <= Track_EndZ->GetNbinsX(); xx++){

double a222  =  Track_EndZ->GetBin(xx);

double ac  =  Track_EndZ->GetBinContent(a222);
double ac2 =  Track_EndZ->GetBinError(a222);


double error_108SCE = abs(1-x7_108[xx])*ac;
double error_92SCE  = abs(1-x7_92[xx])*ac;

if(x7_108[xx]==0){
 error_108SCE   = 0;
}

if(x7_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );


Track_EndZ_Systematics->SetBinContent(a222,ac);
Track_EndZ_Systematics->SetBinError(a222,error);

Track_EndZ_Only_Systematics->SetBinContent(a222,ac);
Track_EndZ_Only_Systematics->SetBinError(a222,error2);

Track_EndZ_Noerror->SetBinContent(a222,ac);
Track_EndZ_Noerror->SetBinError(a222,0);

}


  const Int_t n8 = 21;

   Double_t x8_92[n8]   ={0,0, 0, 0, 0.995142, 0.99546, 0.999187, 1.01211, 1.00034, 1.00975, 0.959799, 1.02713, 0.993313, 0.986223, 0.988428, 1.00009, 1.01917, 0.959324, 1.06916, 1.15803, 0};
   Double_t x8_108[n8]  ={0,0, 0, 0, 1.03639, 1.06725, 0.94481, 0.988194, 1.01961, 1.02758, 0.995928, 0.976609, 0.992979, 1.02628, 1.01216, 0.981447, 0.977528, 1.075, 0.906285, 0.88905, 0};



for(int xx=1; xx <= Track_Phi->GetNbinsX(); xx++){

double a222  =  Track_Phi->GetBin(xx);

double ac  =  Track_Phi->GetBinContent(a222);
double ac2 =  Track_Phi->GetBinError(a222);


double error_108SCE = abs(1-x8_108[xx])*ac;
double error_92SCE  = abs(1-x8_92[xx])*ac;

if(x8_108[xx]==0){
 error_108SCE   = 0;
}

if(x8_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );

Track_Phi_Systematics->SetBinContent(a222,ac);
Track_Phi_Systematics->SetBinError(a222,error);

Track_Phi_Only_Systematics->SetBinContent(a222,ac);
Track_Phi_Only_Systematics->SetBinError(a222,error2);

Track_Phi_Noerror->SetBinContent(a222,ac);
Track_Phi_Noerror->SetBinError(a222,0);

}



   const Int_t n9 = 61;

   Double_t x9_92[n9]   ={0,0, 0, 0.977684, 0.977684, 0.977684, 1.62947, 1.04752, 1.01842, 1.08632, 0.873675, 0.994255, 1.03879, 1.08416, 0.97065, 1.00358, 1.04707, 0.973319, 1.00693, 0.92747, 1.04684, 1.01466, 0.960147, 1.05238, 0.964132, 1.03814, 0.992035, 0.944035, 0.979795, 1.00426, 1.05096, 0.954617, 0.98903, 0.99941, 1.00087, 0.990287, 1.06716, 0.942417, 1.05151, 0.942002, 0.991377, 1.06571, 1.06345, 1.03086, 1.01123, 1.04788, 0.878047, 0.947601, 1.09159, 0.900787, 1.05749, 1.05696, 0.977684, 1.13205, 0.869052, 1.46653, 1.2221, 1.95537, 0.651789, 0, 0};
   Double_t x9_108[n9]  ={0,0, 0, 0.96843, 1.21054, 2.90529, 0.581058, 0.903868, 1.0459, 1.16212, 1.06066, 1.03299, 1.03489, 0.881963, 0.989483, 1.03091, 1.00927, 0.946716, 0.99254, 1.00852, 0.977155, 0.975048, 0.988329, 0.988648, 1.00732, 1.00927, 1.03147, 0.989525, 1.03939, 0.955615, 0.996861, 1.00083, 0.964727, 1.01819, 1.03199, 1.01421, 0.950606, 1.01675, 0.978732, 1.08092, 1.00053, 1.04556, 1.01217, 0.949215, 1.06481, 0.954529, 1.02338, 0.999174, 1.06948, 0.94481, 0.895341, 0.944219, 0.889909, 0.96843, 1.08948, 0.538017, 0.96843, 0.96843, 0.484215, 0.96843, 0};



for(int xx=1; xx <= COSMIC_8905->GetNbinsX(); xx++){

double a222  =  COSMIC_8905->GetBin(xx);

double ac  =  COSMIC_8905->GetBinContent(a222);
double ac2 =  COSMIC_8905->GetBinError(a222);


double error_108SCE = abs(1-x9_108[xx])*ac;
double error_92SCE  = abs(1-x9_92[xx])*ac;

if(x9_108[xx]==0){
 error_108SCE   = 0;
}

if(x9_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );

Track_Theta_Systematics->SetBinContent(a222,ac);
Track_Theta_Systematics->SetBinError(a222,error);

Track_Theta_Only_Systematics->SetBinContent(a222,ac);
Track_Theta_Only_Systematics->SetBinError(a222,error2);

Track_Theta_Noerror->SetBinContent(a222,ac);
Track_Theta_Noerror->SetBinError(a222,0);

}



   const Int_t n10 = 16;

   Double_t x10_92[n10]   ={0,1.10681, 1.00401, 1.01933, 0.994957, 0.981707, 0.98851, 0.995198, 1.02935, 0.987217, 1.0223, 0.991288, 0.999843, 1.01257, 0.985679, 0.907849};
   Double_t x10_108[n10]  ={0,0.96305, 0.996238, 1.01229, 1.02223, 0.970018, 1.02636, 0.99249, 0.979647, 0.989212, 0.990973, 1.02159, 0.982167, 1.01442, 1.00658, 0.963109};



for(int xx=1; xx <= COSMIC_8901->GetNbinsX(); xx++){

double a222  =  COSMIC_8901->GetBin(xx);

double ac  =  COSMIC_8901->GetBinContent(a222);
double ac2 =  COSMIC_8901->GetBinError(a222);


double error_108SCE = abs(1-x10_108[xx])*ac;
double error_92SCE  = abs(1-x10_92[xx])*ac;

if(x10_108[xx]==0){
 error_108SCE   = 0;
}

if(x10_92[xx]==0){
 error_92SCE   = 0;
}


double errorSCE = (error_92SCE + error_108SCE)/2;

double error    = sqrt( (ac2*ac2)+(errorSCE*errorSCE) );
double error2   = sqrt( (errorSCE*errorSCE)  );

Track_Azimuth_Systematics->SetBinContent(a222,ac);
Track_Azimuth_Systematics->SetBinError(a222,error);

Track_Azimuth_Only_Systematics->SetBinContent(a222,ac);
Track_Azimuth_Only_Systematics->SetBinError(a222,error2);

Track_Azimuth_Noerror->SetBinContent(a222,ac);
Track_Azimuth_Noerror->SetBinError(a222,0);

}



TGraphErrors *graph = new TGraphErrors(eve.size(), eve.data(), particl.data(), exl.data(), eyl.data());
graph->SetTitle("Number of tracks per 100 events  ;Event Bundles;Number of tracks");
graph -> GetXaxis() -> CenterTitle();
graph -> GetYaxis() -> CenterTitle();
   graph->SetLineColor(2);
   graph->SetMarkerStyle(22);
   graph->SetMarkerColor(2);
   graph->SetMaximum(1600);
    graph->SetMinimum(0);


//   TF1 *fitFunction = new TF1("fitFunction", "pol1", eve.front(), eve.back()); // pol1 for a linear fit
//    graph->Fit(fitFunction, "R"); // "R" for fit range defined by the x-axis range

    TF1 *fitFunction = new TF1("fitFunction", "[0]", eve.front(), eve.back()); 
    fitFunction->SetParameter(0, 1200); // Set the initial parameter value to 1200
    graph->Fit(fitFunction, "R");

  // Display the fit function parameters
    fitFunction->Draw("same");

graph->Draw("ap");
gStyle->SetOptFit(1111);

*/

Track_Multiplicity->DrawNormalized("HIST E");
//Track_Zenith->DrawNormalized("HIST E");
//Com->DrawNormalized("HIST E");
//E_TRUTH->DrawNormalized("HIST E");
//Track_Truth_Gene->DrawNormalized("HIST E");
//h2_min_dt0->Draw("colz");


TH1F *h2_min_dt3= (TH1F*)h2_min_dt1->Clone("h2_min_dt3");
h2_min_dt3->Add(h2_min_dt2);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
fout->cd();

HITS2->Write();

E_TRUTH->Write();

//COSMIC_8901->Write();
//Track_Zenith->Write();
//f22ms->Write();

Track_Phi_Noerror->Write();
Track_Phi_Systematics->Write();
Track_Phi_Only_Systematics->Write();


Track_Theta_Noerror->Write();
Track_Theta_Systematics->Write();
Track_Theta_Only_Systematics->Write();


Track_Azimuth_Noerror->Write();
Track_Azimuth_Systematics->Write();
Track_Azimuth_Only_Systematics->Write();



HITS->Write();

Com->Write();
Pur->Write();
Cos->Write();

Track_Truth_Gene->Write();
Track_Truth_ProductionY->Write();
Track_Truth_DTMin->Write();
Track_Truth_MinDT->Write();
Track_Truth_DT->Write();
Track_Truth_Min->Write();

Track_Multiplicity->Write();
Track_Length->Write();
Track_Zenith->Write();
Track_Phi->Write();
Track_AngleYZ->Write();

E_TRUTH52->Write();
E_TRUTH50->Write();

Track_Truth_ProductionY52->Write();
Track_Truth_ProductionY50->Write();
h2_min_dt1->Write();
h2_min_dt2->Write();
h2_min_dt3->Write();
h2_min_dt0->Write();

Track_StartY->Write();
Track_StartY_Only_Systematics->Write();
Track_StartY_Systematics->Write();
Track_StartY_Noerror->Write();

Track_EndY->Write();
Track_EndY_Only_Systematics->Write();
Track_EndY_Systematics->Write();
Track_EndY_Noerror->Write();

Track_StartZ->Write();
Track_StartZ_Only_Systematics->Write();
Track_StartZ_Systematics->Write();
Track_StartZ_Noerror->Write();

Track_EndZ->Write();
Track_EndZ_Only_Systematics->Write();
Track_EndZ_Systematics->Write();
Track_EndZ_Noerror->Write();


Track_Multiplicity_Systematics->Write();
Track_Zenith_Systematics->Write();
Track_LengthYZ_Systematics->Write();

Track_Multiplicity_Only_Systematics->Write();
Track_Zenith_Only_Systematics->Write();
Track_LengthYZ_Only_Systematics->Write();

Track_Multiplicity_Noerror->Write();
Track_Zenith_Noerror->Write();
Track_LengthYZ_Noerror->Write();

Parallel_per_cone->Write();
TCOSMIC_8904_2->Write();
TCOSMIC_8904_3->Write();
TCOSMIC_8904_1->Write();
t1->Write();
f2D->Write();
f2Dss->Write();
Angle->Write();
Angle2->Write();

f2ms->Write();
f2me->Write();

//f22ms->Write();
//fffms->Write();
//f33ms->Write();
Air->Write();
Single->Write();
Counter->Write();
COSMIC_8901->Write();

COSMIC_8905->Write();
COSMIC_8907->Write();
COSMIC_8908->Write();


fout->Close();



}//C1
